import "utils/pack/u32/unpack128.zok" as unpack128
import "utils/pack/u32/pack128.zok" as pack128 
import "utils/pack/u32/nonStrictUnpack256.zok" as nonStrictUnpack256 //cast field to u32[8] array
import "utils/casts/u32_to_field.zok" as u32_to_field 
import "utils/casts/u32_4_to_bool_128.zok" as u32_to_bool128 
import "utils/casts/u32_8_to_bool_256.zok" as u32_to_bool256 

def booleanXOR(bool bool1, bool bool2) -> (bool):
    bool xor = (bool1 || bool2) && !(bool1 && bool2)
    return xor

def booleanXOR_5(bool bool1, bool bool2, bool bool3, bool bool4, bool bool5) -> (bool):
    bool result = booleanXOR(bool1, bool2)
    result = booleanXOR(result, bool3)
    result = booleanXOR(result, bool4)
    result = booleanXOR(result, bool5)
    return result


//25 = width of the permutation
def keccak_f(bool[25][256] A) -> (bool[5][256]):

    bool[256] zeros = [false; 256]
    bool[5][256] C = [zeros, zeros, zeros, zeros, zeros]
    bool[5][256] D = [...C]
    bool[25][256] B = [...C, ...C, ...C, ...C, ...C]
    
    //round constant RC
    //field [24] RC = [1, 32898, 9223372036854808714, 9223372039002292224, 32907, 2147483649, 9223372039002292353, 9223372036854808585, 138, 136, 2147516425, 2147483658, 2147516555, 9223372036854775947, 9223372036854808713, 9223372036854808579, 9223372036854808578, 9223372036854775936, 32778, 9223372039002259466, 9223372039002292353, 9223372036854808704, 2147483649, 9223372039002292232]

    for field ii in 0..24 do

        for field jj in 0..255 do

            // C
            // compiler bug #763 (https://github.com/Zokrates/ZoKrates/issues/763) - workaround: use temp0
            bool temp0 = booleanXOR_5(A[0][jj], A[1][jj], A[2][jj], A[3][jj], A[4][jj])
            C[0][jj] = temp0
            bool temp1 = booleanXOR_5(A[5][jj], A[6][jj], A[7][jj], A[8][jj], A[9][jj])
            C[1][jj] = temp1
            bool temp2 = booleanXOR_5(A[10][jj], A[11][jj], A[12][jj], A[13][jj], A[14][jj])
            C[2][jj] = temp2
            bool temp3 = booleanXOR_5(A[15][jj], A[16][jj], A[17][jj], A[18][jj], A[19][jj])
            C[3][jj] = temp3
            bool temp4 = booleanXOR_5(A[20][jj], A[21][jj], A[22][jj], A[23][jj], A[24][jj])
            C[4][jj] = temp4

            //D
    
        
        endfor

    endfor


    return C

def main() -> (bool[5][256]):
    
    bool[256] aux1 = [false; 256]
    bool[5][256] aux2 = [aux1, aux1, aux1, aux1, aux1]
    bool[256] aux3 = [true; 256]
    bool[5][256] aux4 = [aux3, aux3, aux3, aux3, aux3]

    bool[25][256] A = [...aux2, ...aux2, ...aux2, ...aux2, ...aux4]


    return keccak_f(A)