import "utils/pack/bool/pack256.zok" as pack256 
import "utils/pack/bool/nonStrictUnpack256.zok" as nonStrictUnpack256 

//boolean xor not provided by zokrates, I used this workaround to have it
def booleanXOR(bool bool1, bool bool2) -> (bool):
    bool xor = (bool1 || bool2) && !(bool1 && bool2)
    return xor

//boolean xor of 5 inputs
def booleanXOR_5(bool bool1, bool bool2, bool bool3, bool bool4, bool bool5) -> (bool):
    bool result = booleanXOR(bool1, bool2)
    result = booleanXOR(result, bool3)
    result = booleanXOR(result, bool4)
    result = booleanXOR(result, bool5)
    return result


//25 = width of the permutation
def keccak_f(bool[25][256] A) -> (bool[5][256]):

    bool[256] zeros = [false; 256]
    bool[5][256] C = [zeros, zeros, zeros, zeros, zeros]
    bool[5][256] D = [...C]
    bool[25][256] B = [...C, ...C, ...C, ...C, ...C]

    bool[192] aux_zeros = [false; 192]
    bool[64] aux_ones = [true; 64]
    bool[256] getLast8bytes = [...aux_zeros, ...aux_ones]
    
    //round constant RC
    //field [24] RC = [1, 32898, 9223372036854808714, 9223372039002292224, 32907, 2147483649, 9223372039002292353, 9223372036854808585, 138, 136, 2147516425, 2147483658, 2147516555, 9223372036854775947, 9223372036854808713, 9223372036854808579, 9223372036854808578, 9223372036854775936, 32778, 9223372039002259466, 9223372039002292353, 9223372036854808704, 2147483649, 9223372039002292232]

    for field ii in 0..24 do

        for field jj in 0..256 do

            // C
            C[0][jj] = booleanXOR_5(A[0][jj], A[1][jj], A[2][jj], A[3][jj], A[4][jj])
            C[1][jj] = booleanXOR_5(A[5][jj], A[6][jj], A[7][jj], A[8][jj], A[9][jj])
            C[2][jj] = booleanXOR_5(A[10][jj], A[11][jj], A[12][jj], A[13][jj], A[14][jj])
            C[3][jj] = booleanXOR_5(A[15][jj], A[16][jj], A[17][jj], A[18][jj], A[19][jj])
            C[4][jj] = booleanXOR_5(A[20][jj], A[21][jj], A[22][jj], A[23][jj], A[24][jj])

            //D
            //smartPool example code: 
            //D[0]=C[4] ^ ((C[1] * 2)&0xffffffffffffffff | (C[1] / (2 ** 63)));
            //D[1]=C[0] ^ ((C[2] * 2)&0xffffffffffffffff | (C[2] / (2 ** 63)));
            //D[2]=C[1] ^ ((C[3] * 2)&0xffffffffffffffff | (C[3] / (2 ** 63)));
            //D[3]=C[2] ^ ((C[4] * 2)&0xffffffffffffffff | (C[4] / (2 ** 63)));
            //D[4]=C[3] ^ ((C[0] * 2)&0xffffffffffffffff | (C[0] / (2 ** 63)));
            //
            //  C * 2 means that all digits shift one place to the right (gaps filled with zeros)
            //  C / (2 ** 63) means that all digits shift 63 places to the right ((gaps filled with zeros))
            //let's compute the shifts
            bool oneShiftLeft_C0 = if jj == 255 then false else C[0][jj+1] fi  
            bool sixtytreeShiftsRight_C0 = if jj < 63 then false else C[0][jj-63] fi  
            bool oneShiftLeft_C1 = if jj == 255 then false else C[1][jj+1] fi
            bool sixtytreeShiftsRight_C1 = if jj < 63 then false else C[1][jj-63] fi
            bool oneShiftLeft_C2 = if jj == 255 then false else C[2][jj+1] fi
            bool sixtytreeShiftsRight_C2 = if jj < 63 then false else C[2][jj-63] fi
            bool oneShiftLeft_C3 =if jj == 255 then false else C[3][jj+1] fi
            bool sixtytreeShiftsRight_C3 = if jj < 63 then false else C[3][jj-63] fi
            bool oneShiftLeft_C4 = if jj == 255 then false else C[4][jj+1] fi
            bool sixtytreeShiftsRight_C4 = if jj < 63 then false else C[4][jj-63] fi
            //let's calculate D
            D[0][jj] = booleanXOR(C[4][jj], ( (oneShiftLeft_C1 && getLast8bytes[jj]) || sixtytreeShiftsRight_C1 ))
            D[1][jj] = booleanXOR(C[0][jj], ( (oneShiftLeft_C2 && getLast8bytes[jj]) || sixtytreeShiftsRight_C2 ))
            D[2][jj] = booleanXOR(C[1][jj], ( (oneShiftLeft_C3 && getLast8bytes[jj]) || sixtytreeShiftsRight_C3 ))
            D[3][jj] = booleanXOR(C[2][jj], ( (oneShiftLeft_C4 && getLast8bytes[jj]) || sixtytreeShiftsRight_C4 ))
            D[4][jj] = booleanXOR(C[3][jj], ( (oneShiftLeft_C0 && getLast8bytes[jj]) || sixtytreeShiftsRight_C0 ))  
        
        endfor

    endfor


    return D

def main() -> (field[5]):

    field[25] A_field = [1,2,3,4,5,6,7,0,0,0,0,0,0,12,13,0,0,0,0,0,0,0,3,2,1] 

    //cast from field[25] to bool[25][256]
    bool[256] zeros = [false; 256]
    bool[25][256] A_bool = [zeros; 25]

    for field kk in 0..25 do

        bool[256] tempForCasting = nonStrictUnpack256(A_field[kk])
        
        for field jj in 0..256 do
    
            A_bool[kk][jj] = tempForCasting[jj]
    
        endfor

    endfor

    bool[5][256] returnedvalue = keccak_f(A_bool)
    //cast back from bool to field
    field[5] back_to_field = [pack256(returnedvalue[0]), pack256(returnedvalue[1]),pack256(returnedvalue[2]),pack256(returnedvalue[3]),pack256(returnedvalue[4])]
    return back_to_field
